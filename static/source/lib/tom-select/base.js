!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).TomSelect = e() }(this, function () { "use strict"; function t(t, e) { t.split(/\s+/).forEach(t => { e(t) }) } class e { constructor() { this._events = {} } on(e, i) { t(e, t => { this._events[t] = this._events[t] || [], this._events[t].push(i) }) } off(e, i) { var s = arguments.length; 0 !== s ? t(e, t => { if (1 === s) return delete this._events[t]; t in this._events != !1 && this._events[t].splice(this._events[t].indexOf(i), 1) }) : this._events = {} } trigger(e, ...i) { var s = this; t(e, t => { if (t in s._events != !1) for (let e of s._events[t]) e.apply(s, i) }) } } var i; const s = new RegExp("[̀-ͯ·ʾ]", "g"); var n; const o = { "æ": "ae", "ⱥ": "a", "ø": "o" }, r = new RegExp(Object.keys(o).join("|"), "g"), l = [[67, 67], [160, 160], [192, 438], [452, 652], [961, 961], [1019, 1019], [1083, 1083], [1281, 1289], [1984, 1984], [5095, 5095], [7429, 7441], [7545, 7549], [7680, 7935], [8580, 8580], [9398, 9449], [11360, 11391], [42792, 42793], [42802, 42851], [42873, 42897], [42912, 42922], [64256, 64260], [65313, 65338], [65345, 65370]], a = t => t.normalize("NFKD").replace(s, "").toLowerCase().replace(r, function (t) { return o[t] }), c = (t, e = "|") => t.length > 1 ? "(?:" + t.join(e) + ")" : t[0], d = t => { if (1 === t.length) return [[t]]; var e = []; return d(t.substring(1)).forEach(function (i) { var s = i.slice(0); s[0] = t.charAt(0) + s[0], e.push(s), (s = i.slice(0)).unshift(t.charAt(0)), e.push(s) }), e }, h = t => { return void 0 === n && (n = (() => { var t = {}; l.forEach(e => { for (let i = e[0]; i <= e[1]; i++) { let e = String.fromCharCode(i), s = a(e); s != e.toLowerCase() && (s in t || (t[s] = [s]), t[s].push(e)) } }); var e = Object.keys(t); e = e.sort((t, e) => e.length - t.length), i = new RegExp("(" + c(e) + "[̀-ͯ·ʾ]*)", "g"); var s = {}; return e.sort((t, e) => t.length - e.length).forEach(e => { var i = d(e).map(e => (e = e.map(e => t.hasOwnProperty(e) ? c(t[e]) : e), c(e, ""))); s[e] = c(i) }), s })()), t.normalize("NFKD").toLowerCase().split(i).map(t => { if ("" == t) return ""; const e = a(t); if (n.hasOwnProperty(e)) return n[e]; const i = t.normalize("NFC"); return i != t ? c([t, i]) : t }).join("") }, p = (t, e) => { if (t) return t[e] }, u = (t, e) => { if (t) { for (var i, s = e.split("."); (i = s.shift()) && (t = t[i]);); return t } }, g = (t, e, i) => { var s, n; return t ? -1 === (n = (t += "").search(e.regex)) ? 0 : (s = e.string.length / t.length, 0 === n && (s += .5), s * i) : 0 }, m = t => (t + "").replace(/([\$\(-\+\.\?\[-\^\{-\}])/g, "\\$1"), v = (t, e) => { var i = t[e]; i && !Array.isArray(i) && (t[e] = [i]) }, f = (t, e) => { if (Array.isArray(t)) t.forEach(e); else for (var i in t) t.hasOwnProperty(i) && e(t[i], i) }, y = (t, e) => "number" == typeof t && "number" == typeof e ? t > e ? 1 : t < e ? -1 : 0 : (t = a(t + "").toLowerCase()) > (e = a(e + "").toLowerCase()) ? 1 : e > t ? -1 : 0; class O { constructor(t, e) { this.items = t, this.settings = e || { diacritics: !0 } } tokenize(t, e, i) { if (!t || !t.length) return []; const s = [], n = t.split(/\s+/); var o; return i && (o = new RegExp("^(" + Object.keys(i).map(m).join("|") + "):(.*)$")), n.forEach(t => { let i, n = null, r = null; o && (i = t.match(o)) && (n = i[1], t = i[2]), t.length > 0 && (r = m(t), this.settings.diacritics && (r = h(r)), e && (r = "\\b" + r)), s.push({ string: t, regex: r ? new RegExp(r, "iu") : null, field: n }) }), s } getScoreFunction(t, e) { var i = this.prepareSearch(t, e); return this._getScoreFunction(i) } _getScoreFunction(t) { const e = t.tokens, i = e.length; if (!i) return function () { return 0 }; const s = t.options.fields, n = t.weights, o = s.length, r = t.getAttrFn; if (!o) return function () { return 1 }; const l = 1 === o ? function (t, e) { const i = s[0].field; return g(r(e, i), t, n[i]) } : function (t, e) { var i = 0; if (t.field) { const s = r(e, t.field); !t.regex && s ? i += 1 / o : i += g(s, t, 1) } else f(n, (s, n) => { i += g(r(e, n), t, s) }); return i / o }; return 1 === i ? function (t) { return l(e[0], t) } : "and" === t.options.conjunction ? function (t) { for (var s, n = 0, o = 0; n < i; n++) { if ((s = l(e[n], t)) <= 0) return 0; o += s } return o / i } : function (t) { var s = 0; return f(e, e => { s += l(e, t) }), s / i } } getSortFunction(t, e) { var i = this.prepareSearch(t, e); return this._getSortFunction(i) } _getSortFunction(t) { var e, i, s; const n = this, o = t.options, r = !t.query && o.sort_empty ? o.sort_empty : o.sort, l = [], a = [], c = function (e, i) { return "$score" === e ? i.score : t.getAttrFn(n.items[i.id], e) }; if (r) for (e = 0, i = r.length; e < i; e++)(t.query || "$score" !== r[e].field) && l.push(r[e]); if (t.query) { for (s = !0, e = 0, i = l.length; e < i; e++)if ("$score" === l[e].field) { s = !1; break } s && l.unshift({ field: "$score", direction: "desc" }) } else for (e = 0, i = l.length; e < i; e++)if ("$score" === l[e].field) { l.splice(e, 1); break } for (e = 0, i = l.length; e < i; e++)a.push("desc" === l[e].direction ? -1 : 1); const d = l.length; if (d) { if (1 === d) { const t = l[0].field, e = a[0]; return function (i, s) { return e * y(c(t, i), c(t, s)) } } return function (t, e) { var i, s, n; for (i = 0; i < d; i++)if (n = l[i].field, s = a[i] * y(c(n, t), c(n, e))) return s; return 0 } } return null } prepareSearch(t, e) { const i = {}; var s = Object.assign({}, e); if (v(s, "sort"), v(s, "sort_empty"), s.fields) { v(s, "fields"); const t = []; s.fields.forEach(e => { "string" == typeof e && (e = { field: e, weight: 1 }), t.push(e), i[e.field] = "weight" in e ? e.weight : 1 }), s.fields = t } return { options: s, query: t.toLowerCase().trim(), tokens: this.tokenize(t, s.respect_word_boundaries, i), total: 0, items: [], weights: i, getAttrFn: s.nesting ? u : p } } search(t, e) { var i, s; s = this.prepareSearch(t, e), e = s.options, t = s.query; const n = e.score || this._getScoreFunction(s); t.length ? f(this.items, (t, o) => { i = n(t), (!1 === e.filter || i > 0) && s.items.push({ score: i, id: o }) }) : f(this.items, (t, e) => { s.items.push({ score: 1, id: e }) }); const o = this._getSortFunction(s); return o && s.items.sort(o), s.total = s.items.length, "number" == typeof e.limit && (s.items = s.items.slice(0, e.limit)), s } } const w = t => { if (t.jquery) return t[0]; if (t instanceof HTMLElement) return t; if (t.indexOf("<") > -1) { let e = document.createElement("div"); return e.innerHTML = t.trim(), e.firstChild } return document.querySelector(t) }, b = t => t.replace(/['"\\]/g, "\\$&"), I = (t, e) => { var i = document.createEvent("HTMLEvents"); i.initEvent(e, !0, !1), t.dispatchEvent(i) }, _ = (t, e) => { Object.assign(t.style, e) }, S = (t, ...e) => { var i = C(e); (t = F(t)).map(t => { i.map(e => { t.classList.add(e) }) }) }, A = (t, ...e) => { var i = C(e); (t = F(t)).map(t => { i.map(e => { t.classList.remove(e) }) }) }, C = t => { var e = []; return f(t, t => { "string" == typeof t && (t = t.trim().split(/[\11\12\14\15\40]/)), Array.isArray(t) && (e = e.concat(t)) }), e.filter(Boolean) }, F = t => (Array.isArray(t) || (t = [t]), t), x = (t, e, i) => { if (!i || i.contains(t)) for (; t && t.matches;) { if (t.matches(e)) return t; t = t.parentNode } }, k = (t, e = 0) => e > 0 ? t[t.length - 1] : t[0], L = t => 0 === Object.keys(t).length, P = (t, e) => { if (!t) return -1; e = e || t.nodeName; for (var i = 0; t = t.previousElementSibling;)t.matches(e) && i++; return i }, E = (t, e) => { f(e, (e, i) => { null == e ? t.removeAttribute(i) : t.setAttribute(i, "" + e) }) }, T = (t, e) => { t.parentNode && t.parentNode.replaceChild(e, t) }, V = (t, e) => { if (null === e) return; if ("string" == typeof e) { if (!e.length) return; e = new RegExp(e, "i") } const i = t => 3 === t.nodeType ? (t => { var i = t.data.match(e); if (i && t.data.length > 0) { var s = document.createElement("span"); s.className = "highlight"; var n = t.splitText(i.index); n.splitText(i[0].length); var o = n.cloneNode(!0); return s.appendChild(o), T(n, s), 1 } return 0 })(t) : ((t => { if (1 === t.nodeType && t.childNodes && !/(script|style)/i.test(t.tagName) && ("highlight" !== t.className || "SPAN" !== t.tagName)) for (var e = 0; e < t.childNodes.length; ++e)e += i(t.childNodes[e]) })(t), 0); i(t) }, $ = t => { var e = t.querySelectorAll("span.highlight"); Array.prototype.forEach.call(e, function (t) { var e = t.parentNode; e.replaceChild(t.firstChild, t), e.normalize() }) }, j = 65, q = 13, D = 27, N = 37, R = 38, H = 39, z = 40, K = 8, B = 46, M = 9, Q = "undefined" != typeof navigator && /Mac/.test(navigator.userAgent) ? "metaKey" : "ctrlKey"; var G = { options: [], optgroups: [], plugins: [], delimiter: ",", splitOn: null, persist: !0, diacritics: !0, create: null, createOnBlur: !1, createFilter: null, highlight: !0, openOnFocus: !0, shouldOpen: null, maxOptions: 50, maxItems: null, hideSelected: null, duplicates: !1, addPrecedence: !1, selectOnTab: !1, preload: null, allowEmptyOption: !1, loadThrottle: 300, loadingClass: "loading", dataAttr: null, optgroupField: "optgroup", valueField: "value", labelField: "text", disabledField: "disabled", optgroupLabelField: "label", optgroupValueField: "value", lockOptgroupOrder: !1, sortField: "$order", searchField: ["text"], searchConjunction: "and", mode: null, wrapperClass: "ts-wrapper", controlClass: "ts-control", dropdownClass: "ts-dropdown", dropdownContentClass: "ts-dropdown-content", itemClass: "item", optionClass: "option", dropdownParent: null, copyClassesToDropdown: !1, placeholder: null, hidePlaceholder: null, shouldLoad: function (t) { return t.length > 0 }, render: {} }; const J = t => null == t ? null : U(t), U = t => "boolean" == typeof t ? t ? "1" : "0" : t + "", X = t => (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"), Y = (t, e) => { var i; return function (s, n) { var o = this; i && (o.loading = Math.max(o.loading - 1, 0), clearTimeout(i)), i = setTimeout(function () { i = null, o.loadedSearches[s] = !0, t.call(o, s, n) }, e) } }, W = (t, e, i) => { var s, n = t.trigger, o = {}; for (s in t.trigger = function () { var i = arguments[0]; if (-1 === e.indexOf(i)) return n.apply(t, arguments); o[i] = arguments }, i.apply(t, []), t.trigger = n, o) n.apply(t, o[s]) }, Z = t => ({ start: t.selectionStart || 0, length: (t.selectionEnd || 0) - (t.selectionStart || 0) }), tt = (t, e = !1) => { t && (t.preventDefault(), e && t.stopPropagation()) }, et = (t, e, i, s) => { t.addEventListener(e, i, s) }, it = (t, e) => { return !!e && (!!e[t] && 1 === (e.altKey ? 1 : 0) + (e.ctrlKey ? 1 : 0) + (e.shiftKey ? 1 : 0) + (e.metaKey ? 1 : 0)) }, st = (t, e) => { const i = t.getAttribute("id"); return i || (t.setAttribute("id", e), e) }, nt = t => t.replace(/[\\"']/g, "\\$&"), ot = (t, e) => { e && t.append(e) }; function rt(t, e) { var i = Object.assign({}, G, e), s = i.dataAttr, n = i.labelField, o = i.valueField, r = i.disabledField, l = i.optgroupField, a = i.optgroupLabelField, c = i.optgroupValueField, d = t.tagName.toLowerCase(), h = t.getAttribute("placeholder") || t.getAttribute("data-placeholder"); if (!h && !i.allowEmptyOption) { let e = t.querySelector('option[value=""]'); e && (h = e.textContent) } var p, u, g, m, v, y, O = { placeholder: h, options: [], optgroups: [], items: [], maxItems: null }; return "select" === d ? (u = O.options, g = {}, m = 1, v = (t => { var e = Object.assign({}, t.dataset), i = s && e[s]; return "string" == typeof i && i.length && (e = Object.assign(e, JSON.parse(i))), e }), y = ((t, e) => { var s = J(t.value); if (null != s && (s || i.allowEmptyOption)) { if (g.hasOwnProperty(s)) { if (e) { var a = g[s][l]; a ? Array.isArray(a) ? a.push(e) : g[s][l] = [a, e] : g[s][l] = e } } else { var c = v(t); c[n] = c[n] || t.textContent, c[o] = c[o] || s, c[r] = c[r] || t.disabled, c[l] = c[l] || e, c.$option = t, g[s] = c, u.push(c) } t.selected && O.items.push(s) } }), O.maxItems = t.hasAttribute("multiple") ? null : 1, f(t.children, t => { "optgroup" === (p = t.tagName.toLowerCase()) ? (t => { var e, i; (i = v(t))[a] = i[a] || t.getAttribute("label") || "", i[c] = i[c] || m++, i[r] = i[r] || t.disabled, O.optgroups.push(i), e = i[c], f(t.children, t => { y(t, e) }) })(t) : "option" === p && y(t) })) : (() => { const e = t.getAttribute(s); if (e) O.options = JSON.parse(e), f(O.options, t => { O.items.push(t[o]) }); else { var r = t.value.trim() || ""; if (!i.allowEmptyOption && !r.length) return; const e = r.split(i.delimiter); f(e, t => { const e = {}; e[n] = t, e[o] = t, O.options.push(e) }), O.items = e } })(), Object.assign({}, G, O, e) } var lt = 0; return class extends (function (t) { return t.plugins = {}, class extends t { constructor(...t) { super(...t), this.plugins = { names: [], settings: {}, requested: {}, loaded: {} } } static define(e, i) { t.plugins[e] = { name: e, fn: i } } initializePlugins(t) { var e, i; const s = this, n = []; if (Array.isArray(t)) t.forEach(t => { "string" == typeof t ? n.push(t) : (s.plugins.settings[t.name] = t.options, n.push(t.name)) }); else if (t) for (e in t) t.hasOwnProperty(e) && (s.plugins.settings[e] = t[e], n.push(e)); for (; i = n.shift();)s.require(i) } loadPlugin(e) { var i = this.plugins, s = t.plugins[e]; if (!t.plugins.hasOwnProperty(e)) throw new Error('Unable to find "' + e + '" plugin'); i.requested[e] = !0, i.loaded[e] = s.fn.apply(this, [this.plugins.settings[e] || {}]), i.names.push(e) } require(t) { var e = this.plugins; if (!this.plugins.loaded.hasOwnProperty(t)) { if (e.requested[t]) throw new Error('Plugin has circular dependency ("' + t + '")'); this.loadPlugin(t) } return e.loaded[t] } } }(e)) { constructor(t, e) { var i; super(), this.order = 0, this.isOpen = !1, this.isDisabled = !1, this.isInvalid = !1, this.isValid = !0, this.isLocked = !1, this.isFocused = !1, this.isInputHidden = !1, this.isSetup = !1, this.ignoreFocus = !1, this.hasOptions = !1, this.lastValue = "", this.caretPos = 0, this.loading = 0, this.loadedSearches = {}, this.activeOption = null, this.activeItems = [], this.optgroups = {}, this.options = {}, this.userOptions = {}, this.items = [], lt++; var s = w(t); if (s.tomselect) throw new Error("Tom Select already initialized on this element"); s.tomselect = this, i = (window.getComputedStyle && window.getComputedStyle(s, null)).getPropertyValue("direction"), e = rt(s, e), this.settings = e, this.input = s, this.tabIndex = s.tabIndex || 0, this.is_select_tag = "select" === s.tagName.toLowerCase(), this.rtl = /rtl/i.test(i), this.inputId = st(s, "tomselect-" + lt), this.isRequired = s.required, this.sifter = new O(this.options, { diacritics: e.diacritics }), e.mode = e.mode || (1 === e.maxItems ? "single" : "multi"), "boolean" != typeof e.hideSelected && (e.hideSelected = "multi" === e.mode), "boolean" != typeof e.hidePlaceholder && (e.hidePlaceholder = "multi" !== e.mode); var n = e.createFilter; "function" != typeof n && ("string" == typeof n && (n = new RegExp(n)), n instanceof RegExp ? e.createFilter = (t => n.test(t)) : e.createFilter = (() => !0)), this.initializePlugins(e.plugins), this.setupCallbacks(), this.setupTemplates(); const o = w("<div>"), r = w("<div>"), l = this._render("dropdown"), a = w('<div role="listbox" tabindex="-1">'), c = this.input.getAttribute("class") || "", d = e.mode; var h; S(o, e.wrapperClass, c, d), S(r, e.controlClass), ot(o, r), S(l, e.dropdownClass, d), e.copyClassesToDropdown && S(l, c), S(a, e.dropdownContentClass), ot(l, a), w(e.dropdownParent || o).appendChild(l), e.hasOwnProperty("controlInput") ? e.controlInput ? (h = w(e.controlInput), this.focus_node = h) : (h = w("<input/>"), this.focus_node = r) : (h = w('<input type="text" autocomplete="off" size="1" />'), f(["autocorrect", "autocapitalize", "autocomplete"], t => { s.getAttribute(t) && E(h, { [t]: s.getAttribute(t) }) }), h.tabIndex = -1, r.appendChild(h), this.focus_node = h), this.wrapper = o, this.dropdown = l, this.dropdown_content = a, this.control = r, this.control_input = h, this.setup() } setup() { const t = this, e = t.settings, i = t.control_input, s = t.dropdown, n = t.dropdown_content, o = t.wrapper, r = t.control, l = t.input, a = t.focus_node, c = { passive: !0 }, d = t.inputId + "-ts-dropdown"; E(n, { id: d }), E(a, { role: "combobox", "aria-haspopup": "listbox", "aria-expanded": "false", "aria-controls": d }); const h = st(a, t.inputId + "-ts-control"), p = "label[for='" + b(t.inputId) + "']", u = document.querySelector(p), g = t.focus.bind(t); if (u) { et(u, "click", g), E(u, { for: h }); const e = st(u, t.inputId + "-ts-label"); E(a, { "aria-labelledby": e }), E(n, { "aria-labelledby": e }) } if (o.style.width = l.style.width, t.plugins.names.length) { const e = "plugin-" + t.plugins.names.join(" plugin-"); S([o, s], e) } (null === e.maxItems || e.maxItems > 1) && t.is_select_tag && E(l, { multiple: "multiple" }), t.settings.placeholder && E(i, { placeholder: e.placeholder }), !t.settings.splitOn && t.settings.delimiter && (t.settings.splitOn = new RegExp("\\s*" + m(t.settings.delimiter) + "+\\s*")), e.load && e.loadThrottle && (e.load = Y(e.load, e.loadThrottle)), t.control_input.type = l.type, et(s, "click", e => { const i = x(e.target, "[data-selectable]"); i && (t.onOptionSelect(e, i), tt(e, !0)) }), et(r, "click", e => { var s = x(e.target, "[data-ts-item]", r); s && t.onItemSelect(e, s) ? tt(e, !0) : "" == i.value && (t.onClick(), tt(e, !0)) }), et(i, "mousedown", t => { "" !== i.value && t.stopPropagation() }), et(a, "keydown", e => t.onKeyDown(e)), et(i, "keypress", e => t.onKeyPress(e)), et(i, "input", e => t.onInput(e)), et(a, "resize", () => t.positionDropdown(), c), et(a, "blur", e => t.onBlur(e)), et(a, "focus", e => t.onFocus(e)), et(a, "paste", e => t.onPaste(e)); const v = e => { const i = e.composedPath()[0]; if (!o.contains(i) && !s.contains(i)) return t.isFocused && t.blur(), void t.inputState(); tt(e, !0) }; var f = () => { t.isOpen && t.positionDropdown() }; et(document, "mousedown", v), et(window, "scroll", f, c), et(window, "resize", f, c), this._destroy = (() => { document.removeEventListener("mousedown", v), window.removeEventListener("sroll", f), window.removeEventListener("resize", f), u && u.removeEventListener("click", g) }), this.revertSettings = { innerHTML: l.innerHTML, tabIndex: l.tabIndex }, l.tabIndex = -1, l.insertAdjacentElement("afterend", t.wrapper), t.sync(!1), e.items = [], delete e.optgroups, delete e.options, et(l, "invalid", e => { t.isValid && (t.isValid = !1, t.isInvalid = !0, t.refreshState()) }), t.updateOriginalInput(), t.refreshItems(), t.close(!1), t.inputState(), t.isSetup = !0, l.disabled ? t.disable() : t.enable(), t.on("change", this.onChange), S(l, "tomselected", "ts-hidden-accessible"), t.trigger("initialize"), !0 === e.preload && t.load("") } setupOptions(t = [], e = []) { this.addOptions(t), f(e, t => { this.registerOptionGroup(t) }) } setupTemplates() { var t = this.settings.labelField, e = this.settings.optgroupLabelField, i = { optgroup: t => { let e = document.createElement("div"); return e.className = "optgroup", e.appendChild(t.options), e }, optgroup_header: (t, i) => '<div class="optgroup-header">' + i(t[e]) + "</div>", option: (e, i) => "<div>" + i(e[t]) + "</div>", item: (e, i) => "<div>" + i(e[t]) + "</div>", option_create: (t, e) => '<div class="create">Add <strong>' + e(t.input) + "</strong>&hellip;</div>", no_results: () => '<div class="no-results">No results found</div>', loading: () => '<div class="spinner"></div>', not_loading: () => { }, dropdown: () => "<div></div>" }; this.settings.render = Object.assign({}, i, this.settings.render) } setupCallbacks() { var t, e, i = { initialize: "onInitialize", change: "onChange", item_add: "onItemAdd", item_remove: "onItemRemove", item_select: "onItemSelect", clear: "onClear", option_add: "onOptionAdd", option_remove: "onOptionRemove", option_clear: "onOptionClear", optgroup_add: "onOptionGroupAdd", optgroup_remove: "onOptionGroupRemove", optgroup_clear: "onOptionGroupClear", dropdown_open: "onDropdownOpen", dropdown_close: "onDropdownClose", type: "onType", load: "onLoad", focus: "onFocus", blur: "onBlur" }; for (t in i) (e = this.settings[i[t]]) && this.on(t, e) } sync(t = !0) { const e = t ? rt(this.input, { delimiter: this.settings.delimiter }) : this.settings; this.setupOptions(e.options, e.optgroups), this.setValue(e.items, !0), this.lastQuery = null } onClick() { if (this.activeItems.length > 0) return this.clearActiveItems(), void this.focus(); this.isFocused && this.isOpen ? this.blur() : this.focus() } onMouseDown() { } onChange() { I(this.input, "input"), I(this.input, "change") } onPaste(t) { var e = this; e.isFull() || e.isInputHidden || e.isLocked ? tt(t) : e.settings.splitOn && setTimeout(() => { var t = e.inputValue(); if (t.match(e.settings.splitOn)) { var i = t.trim().split(e.settings.splitOn); f(i, t => { e.createItem(t) }) } }, 0) } onKeyPress(t) { if (!this.isLocked) { var e = String.fromCharCode(t.keyCode || t.which); return this.settings.create && "multi" === this.settings.mode && e === this.settings.delimiter ? (this.createItem(), void tt(t)) : void 0 } tt(t) } onKeyDown(t) { if (this.isLocked) t.keyCode !== M && tt(t); else { switch (t.keyCode) { case j: if (it(Q, t)) return void this.selectAll(); break; case D: return this.isOpen && (tt(t, !0), this.close()), void this.clearActiveItems(); case z: if (!this.isOpen && this.hasOptions) this.open(); else if (this.activeOption) { let t = this.getAdjacent(this.activeOption, 1); t && this.setActiveOption(t) } return void tt(t); case R: if (this.activeOption) { let t = this.getAdjacent(this.activeOption, -1); t && this.setActiveOption(t) } return void tt(t); case q: return void (this.isOpen && this.activeOption ? (this.onOptionSelect(t, this.activeOption), tt(t)) : this.settings.create && this.createItem() && tt(t)); case N: return void this.advanceSelection(-1, t); case H: return void this.advanceSelection(1, t); case M: return void (this.settings.selectOnTab && (this.isOpen && this.activeOption && (this.onOptionSelect(t, this.activeOption), tt(t)), this.settings.create && this.createItem() && tt(t))); case K: case B: return void this.deleteSelection(t) }this.isInputHidden && !it(Q, t) && tt(t) } } onInput(t) { if (!this.isLocked) { var e = this.inputValue(); this.lastValue !== e && (this.lastValue = e, this.settings.shouldLoad.call(this, e) && this.load(e), this.refreshOptions(), this.trigger("type", e)) } } onFocus(t) { var e = this.isFocused; if (this.isDisabled) return this.blur(), void tt(t); this.ignoreFocus || (this.isFocused = !0, "focus" === this.settings.preload && this.load(""), e || this.trigger("focus"), this.activeItems.length || (this.showInput(), this.refreshOptions(!!this.settings.openOnFocus)), this.refreshState()) } onBlur(t) { var e = this; if (e.isFocused) { e.isFocused = !1, e.ignoreFocus = !1; var i = () => { e.close(), e.setActiveItem(), e.setCaret(e.items.length), e.trigger("blur") }; e.settings.create && e.settings.createOnBlur ? e.createItem(null, !1, i) : i() } } onOptionSelect(t, e) { var i, s = this; e && (e.parentElement && e.parentElement.matches("[data-disabled]") || (e.classList.contains("create") ? s.createItem(null, !0, () => { s.settings.closeAfterSelect && s.close() }) : void 0 !== (i = e.dataset.value) && (s.lastQuery = null, s.addItem(i), s.settings.closeAfterSelect && s.close(), !s.settings.hideSelected && t.type && /click/.test(t.type) && s.setActiveOption(e)))) } onItemSelect(t, e) { return !this.isLocked && "multi" === this.settings.mode && (tt(t), this.setActiveItem(e, t), !0) } canLoad(t) { return !!this.settings.load && !this.loadedSearches.hasOwnProperty(t) } load(t) { if (!this.canLoad(t)) return; S(this.wrapper, this.settings.loadingClass), this.loading++; const e = this.loadCallback.bind(this); this.settings.load.call(this, t, e) } loadCallback(t, e) { const i = this; i.loading = Math.max(i.loading - 1, 0), i.lastQuery = null, i.clearActiveOption(), i.setupOptions(t, e), i.refreshOptions(i.isFocused && !i.isInputHidden), i.loading || A(i.wrapper, i.settings.loadingClass), i.trigger("load", t, e) } setTextboxValue(t = "") { var e = this.control_input; e.value !== t && (e.value = t, I(e, "update"), this.lastValue = t) } getValue() { return this.is_select_tag && this.input.hasAttribute("multiple") ? this.items : this.items.join(this.settings.delimiter) } setValue(t, e) { W(this, e ? [] : ["change"], () => { this.clear(e), this.addItems(t, e) }) } setMaxItems(t) { 0 === t && (t = null), this.settings.maxItems = t, this.refreshState() } setActiveItem(t, e) { var i, s, n, o, r, l; if ("single" !== this.settings.mode) { if (!t) return this.clearActiveItems(), void (this.isFocused && this.showInput()); if ("click" === (i = e && e.type.toLowerCase()) && it("shiftKey", e) && this.activeItems.length) { for (l = this.getLastActive(), (n = Array.prototype.indexOf.call(this.control.children, l)) > (o = Array.prototype.indexOf.call(this.control.children, t)) && (r = n, n = o, o = r), s = n; s <= o; s++)t = this.control.children[s], -1 === this.activeItems.indexOf(t) && this.setActiveItemClass(t); tt(e) } else "click" === i && it(Q, e) || "keydown" === i && it("shiftKey", e) ? t.classList.contains("active") ? this.removeActiveItem(t) : this.setActiveItemClass(t) : (this.clearActiveItems(), this.setActiveItemClass(t)); this.hideInput(), this.isFocused || this.focus() } } setActiveItemClass(t) { const e = this, i = e.control.querySelector(".last-active"); i && A(i, "last-active"), S(t, "active last-active"), e.trigger("item_select", t), -1 == e.activeItems.indexOf(t) && e.activeItems.push(t) } removeActiveItem(t) { var e = this.activeItems.indexOf(t); this.activeItems.splice(e, 1), A(t, "active") } clearActiveItems() { A(this.activeItems, "active"), this.activeItems = [] } setActiveOption(t) { t !== this.activeOption && (this.clearActiveOption(), t && (this.activeOption = t, E(this.focus_node, { "aria-activedescendant": t.getAttribute("id") }), E(t, { "aria-selected": "true" }), S(t, "active"), this.scrollToOption(t))) } scrollToOption(t, e) { if (!t) return; const i = this.dropdown_content, s = i.clientHeight, n = i.scrollTop || 0, o = t.offsetHeight, r = t.getBoundingClientRect().top - i.getBoundingClientRect().top + n; r + o > s + n ? this.scroll(r - s + o, e) : r < n && this.scroll(r, e) } scroll(t, e) { const i = this.dropdown_content; e && (i.style.scrollBehavior = e), i.scrollTop = t, i.style.scrollBehavior = "" } clearActiveOption() { this.activeOption && (A(this.activeOption, "active"), E(this.activeOption, { "aria-selected": null })), this.activeOption = null, E(this.focus_node, { "aria-activedescendant": null }) } selectAll() { "single" !== this.settings.mode && (this.activeItems = this.controlChildren(), this.activeItems.length && (S(this.activeItems, "active"), this.hideInput(), this.close()), this.focus()) } inputState() { this.control.contains(this.control_input) && (this.activeItems.length > 0 || !this.isFocused && this.settings.hidePlaceholder && this.items.length > 0 ? (this.setTextboxValue(), this.isInputHidden = !0, S(this.wrapper, "input-hidden")) : (this.isInputHidden = !1, A(this.wrapper, "input-hidden"))) } hideInput() { this.inputState() } showInput() { this.inputState() } inputValue() { return this.control_input.value.trim() } focus() { var t = this; t.isDisabled || (t.ignoreFocus = !0, t.focus_node.focus(), setTimeout(() => { t.ignoreFocus = !1, t.onFocus() }, 0)) } blur() { this.focus_node.blur(), this.onBlur() } getScoreFunction(t) { return this.sifter.getScoreFunction(t, this.getSearchOptions()) } getSearchOptions() { var t = this.settings, e = t.sortField; return "string" == typeof t.sortField && (e = [{ field: t.sortField }]), { fields: t.searchField, conjunction: t.searchConjunction, sort: e, nesting: t.nesting } } search(t) { var e, i, s, n = this.getSearchOptions(); if (this.settings.score && "function" != typeof (s = this.settings.score.call(this, t))) throw new Error('Tom Select "score" setting must be a function that returns a function'); if (t !== this.lastQuery ? (this.lastQuery = t, i = this.sifter.search(t, Object.assign(n, { score: s })), this.currentResults = i) : i = Object.assign({}, this.currentResults), this.settings.hideSelected) for (e = i.items.length - 1; e >= 0; e--) { let t = J(i.items[e].id); t && -1 !== this.items.indexOf(t) && i.items.splice(e, 1) } return i } refreshOptions(t = !0) { var e, i, s, n, o, r, l, a, c, d, h; const p = {}, u = []; var g = this, m = g.inputValue(), v = g.search(m), y = g.activeOption, O = g.settings.shouldOpen || !1, w = g.dropdown_content; for (y && (c = y.dataset.value, d = y.closest("[data-group]")), n = v.items.length, "number" == typeof g.settings.maxOptions && (n = Math.min(n, g.settings.maxOptions)), n > 0 && (O = !0), e = 0; e < n; e++) { let t = v.items[e].id, n = g.options[t], l = g.getOption(t, !0); for (g.settings.hideSelected || l.classList.toggle("selected", g.items.includes(t)), o = n[g.settings.optgroupField] || "", i = 0, s = (r = Array.isArray(o) ? o : [o]) && r.length; i < s; i++)o = r[i], g.optgroups.hasOwnProperty(o) || (o = ""), p.hasOwnProperty(o) || (p[o] = document.createDocumentFragment(), u.push(o)), i > 0 && (l = l.cloneNode(!0), E(l, { id: n.$id + "-clone-" + i, "aria-selected": null }), l.classList.add("ts-cloned"), A(l, "active")), c == t && d && d.dataset.group === o && (y = l), p[o].appendChild(l) } this.settings.lockOptgroupOrder && u.sort((t, e) => (g.optgroups[t] && g.optgroups[t].$order || 0) - (g.optgroups[e] && g.optgroups[e].$order || 0)), l = document.createDocumentFragment(), f(u, t => { if (g.optgroups.hasOwnProperty(t) && p[t].children.length) { let e = document.createDocumentFragment(), i = g.render("optgroup_header", g.optgroups[t]); ot(e, i), ot(e, p[t]); let s = g.render("optgroup", { group: g.optgroups[t], options: e }); ot(l, s) } else ot(l, p[t]) }), w.innerHTML = "", ot(w, l), g.settings.highlight && ($(w), v.query.length && v.tokens.length && f(v.tokens, t => { V(w, t.regex) })); var b = t => { let e = g.render(t, { input: m }); return e && (O = !0, w.insertBefore(e, w.firstChild)), e }; if (g.settings.shouldLoad.call(g, m) ? g.loading ? b("loading") : 0 === v.items.length && b("no_results") : b("not_loading"), (a = g.canCreate(m)) && (h = b("option_create")), g.hasOptions = v.items.length > 0 || a, O) { if (v.items.length > 0) { if (!w.contains(y) && "single" === g.settings.mode && g.items.length && (y = g.getOption(g.items[0])), !w.contains(y)) { let t = 0; h && !g.settings.addPrecedence && (t = 1), y = g.selectable()[t] } } else h && (y = h); t && !g.isOpen && (g.open(), g.scrollToOption(y, "auto")), g.setActiveOption(y) } else g.clearActiveOption(), t && g.isOpen && g.close(!1) } selectable() { return this.dropdown_content.querySelectorAll("[data-selectable]") } addOption(t, e = !1) { const i = this; if (Array.isArray(t)) return i.addOptions(t, e), !1; const s = J(t[i.settings.valueField]); return null !== s && !i.options.hasOwnProperty(s) && (t.$order = t.$order || ++i.order, t.$id = i.inputId + "-opt-" + t.$order, i.options[s] = t, i.lastQuery = null, e && (i.userOptions[s] = e, i.trigger("option_add", s, t)), s) } addOptions(t, e = !1) { f(t, t => { this.addOption(t, e) }) } registerOption(t) { return this.addOption(t) } registerOptionGroup(t) { var e = J(t[this.settings.optgroupValueField]); return null !== e && (t.$order = t.$order || ++this.order, this.optgroups[e] = t, e) } addOptionGroup(t, e) { var i; e[this.settings.optgroupValueField] = t, (i = this.registerOptionGroup(e)) && this.trigger("optgroup_add", i, e) } removeOptionGroup(t) { this.optgroups.hasOwnProperty(t) && (delete this.optgroups[t], this.clearCache(), this.trigger("optgroup_remove", t)) } clearOptionGroups() { this.optgroups = {}, this.clearCache(), this.trigger("optgroup_clear") } updateOption(t, e) { const i = this; var s, n; const o = J(t), r = J(e[i.settings.valueField]); if (null === o) return; if (!i.options.hasOwnProperty(o)) return; if ("string" != typeof r) throw new Error("Value must be set in option data"); const l = i.getOption(o), a = i.getItem(o); if (e.$order = e.$order || i.options[o].$order, delete i.options[o], i.uncacheValue(r), i.options[r] = e, l) { if (i.dropdown_content.contains(l)) { const t = i._render("option", e); T(l, t), i.activeOption === l && i.setActiveOption(t) } l.remove() } a && (-1 !== (n = i.items.indexOf(o)) && i.items.splice(n, 1, r), s = i._render("item", e), a.classList.contains("active") && S(s, "active"), T(a, s)), i.lastQuery = null } removeOption(t, e) { t = U(t), this.uncacheValue(t), delete this.userOptions[t], delete this.options[t], this.lastQuery = null, this.trigger("option_remove", t), this.removeItem(t, e) } clearOptions() { this.loadedSearches = {}, this.userOptions = {}, this.clearCache(); var t = {}; f(this.options, (e, i) => { this.items.indexOf(i) >= 0 && (t[i] = this.options[i]) }), this.options = this.sifter.items = t, this.lastQuery = null, this.trigger("option_clear") } getOption(t, e = !1) { const i = J(t); if (null !== i && this.options.hasOwnProperty(i)) { const t = this.options[i]; if (t.$div) return t.$div; if (e) return this._render("option", t) } return null } getAdjacent(t, e, i = "option") { var s; if (!t) return null; s = "item" == i ? this.controlChildren() : this.dropdown_content.querySelectorAll("[data-selectable]"); for (let i = 0; i < s.length; i++)if (s[i] == t) return e > 0 ? s[i + 1] : s[i - 1]; return null } getItem(t) { if ("object" == typeof t) return t; var e = J(t); return null !== e ? this.control.querySelector(`[data-value="${nt(e)}"]`) : null } addItems(t, e) { var i = this, s = Array.isArray(t) ? t : [t]; for (let t = 0, n = (s = s.filter(t => -1 === i.items.indexOf(t))).length; t < n; t++)i.isPending = t < n - 1, i.addItem(s[t], e) } addItem(t, e) { W(this, e ? [] : ["change"], () => { var i, s; const n = this, o = n.settings.mode, r = J(t); if ((!r || -1 === n.items.indexOf(r) || ("single" === o && n.close(), "single" !== o && n.settings.duplicates)) && null !== r && n.options.hasOwnProperty(r) && ("single" === o && n.clear(e), "multi" !== o || !n.isFull())) { if (i = n._render("item", n.options[r]), n.control.contains(i) && (i = i.cloneNode(!0)), s = n.isFull(), n.items.splice(n.caretPos, 0, r), n.insertAtCaret(i), n.isSetup) { if (!n.isPending && n.settings.hideSelected) { let t = n.getOption(r), e = n.getAdjacent(t, 1); e && n.setActiveOption(e) } n.isPending || n.refreshOptions(n.isFocused && "single" !== o), 0 != n.settings.closeAfterSelect && n.isFull() ? n.close() : n.isPending || n.positionDropdown(), n.trigger("item_add", r, i), n.isPending || n.updateOriginalInput({ silent: e }) } (!n.isPending || !s && n.isFull()) && n.refreshState() } }) } removeItem(t = null, e) { const i = this; if (!(t = i.getItem(t))) return; var s, n; const o = t.dataset.value; s = P(t), t.remove(), t.classList.contains("active") && (n = i.activeItems.indexOf(t), i.activeItems.splice(n, 1), A(t, "active")), i.items.splice(s, 1), i.lastQuery = null, !i.settings.persist && i.userOptions.hasOwnProperty(o) && i.removeOption(o, e), s < i.caretPos && i.setCaret(i.caretPos - 1), i.updateOriginalInput({ silent: e }), i.refreshState(), i.positionDropdown(), i.trigger("item_remove", o, t) } createItem(t = null, e = !0, i = (() => { })) { var s, n = this, o = n.caretPos; if (t = t || n.inputValue(), !n.canCreate(t)) return i(), !1; n.lock(); var r = !1, l = t => { if (n.unlock(), !t || "object" != typeof t) return i(); var s = J(t[n.settings.valueField]); if ("string" != typeof s) return i(); n.setTextboxValue(), n.addOption(t, !0), n.setCaret(o), n.addItem(s), n.refreshOptions(e && "single" !== n.settings.mode), i(t), r = !0 }; return s = "function" == typeof n.settings.create ? n.settings.create.call(this, t, l) : { [n.settings.labelField]: t, [n.settings.valueField]: t }, r || l(s), !0 } refreshItems() { this.lastQuery = null, this.isSetup && this.addItems(this.items), this.updateOriginalInput(), this.refreshState() } refreshState() { this.refreshValidityState(); const t = this.isFull(), e = this.isLocked; this.wrapper.classList.toggle("rtl", this.rtl); const i = this.wrapper.classList; i.toggle("focus", this.isFocused), i.toggle("disabled", this.isDisabled), i.toggle("required", this.isRequired), i.toggle("invalid", !this.isValid), i.toggle("locked", e), i.toggle("full", t), i.toggle("input-active", this.isFocused && !this.isInputHidden), i.toggle("dropdown-active", this.isOpen), i.toggle("has-options", L(this.options)), i.toggle("has-items", this.items.length > 0) } refreshValidityState() { this.input.checkValidity && (this.isValid = this.input.checkValidity(), this.isInvalid = !this.isValid) } isFull() { return null !== this.settings.maxItems && this.items.length >= this.settings.maxItems } updateOriginalInput(t = {}) { const e = this; var i, s; const n = e.input.querySelector('option[value=""]'); if (e.is_select_tag) { const t = []; function o(i, s, o) { return i || (i = w('<option value="' + X(s) + '">' + X(o) + "</option>")), i != n && e.input.append(i), t.push(i), i.selected = !0, i } e.input.querySelectorAll("option:checked").forEach(t => { t.selected = !1 }), 0 == e.items.length && "single" == e.settings.mode ? o(n, "", "") : e.items.forEach(n => { i = e.options[n], s = i[e.settings.labelField] || "", t.includes(i.$option) ? o(e.input.querySelector(`option[value="${nt(n)}"]:not(:checked)`), n, s) : i.$option = o(i.$option, n, s) }) } else e.input.value = e.getValue(); e.isSetup && (t.silent || e.trigger("change", e.getValue())) } open() { this.isLocked || this.isOpen || "multi" === this.settings.mode && this.isFull() || (this.isOpen = !0, E(this.focus_node, { "aria-expanded": "true" }), this.refreshState(), _(this.dropdown, { visibility: "hidden", display: "block" }), this.positionDropdown(), _(this.dropdown, { visibility: "visible", display: "block" }), this.focus(), this.trigger("dropdown_open", this.dropdown)) } close(t = !0) { var e = this.isOpen; t && (this.setTextboxValue(), "single" === this.settings.mode && this.items.length && this.hideInput()), this.isOpen = !1, E(this.focus_node, { "aria-expanded": "false" }), _(this.dropdown, { display: "none" }), this.settings.hideSelected && this.clearActiveOption(), this.refreshState(), e && this.trigger("dropdown_close", this.dropdown) } positionDropdown() { if ("body" === this.settings.dropdownParent) { var t = this.control, e = t.getBoundingClientRect(), i = t.offsetHeight + e.top + window.scrollY, s = e.left + window.scrollX; _(this.dropdown, { width: e.width + "px", top: i + "px", left: s + "px" }) } } clear(t) { var e = this; if (e.items.length) { var i = e.controlChildren(); f(i, t => { e.removeItem(t, !0) }), e.showInput(), t || e.updateOriginalInput(), e.trigger("clear") } } insertAtCaret(t) { const e = this.caretPos, i = this.control; i.insertBefore(t, i.children[e]), this.setCaret(e + 1) } deleteSelection(t) { var e, i, s, n; e = t && t.keyCode === K ? -1 : 1, i = Z(this.control_input); const o = []; if (this.activeItems.length) n = k(this.activeItems, e), s = P(n), e > 0 && s++, f(this.activeItems, t => o.push(t)); else if ((this.isFocused || "single" === this.settings.mode) && this.items.length) { const t = this.controlChildren(); e < 0 && 0 === i.start && 0 === i.length ? o.push(t[this.caretPos - 1]) : e > 0 && i.start === this.inputValue().length && o.push(t[this.caretPos]) } const r = o.map(t => t.dataset.value); if (!r.length || "function" == typeof this.settings.onDelete && !1 === this.settings.onDelete.call(this, r, t)) return !1; for (tt(t, !0), void 0 !== s && this.setCaret(s); o.length;)this.removeItem(o.pop()); return this.showInput(), this.positionDropdown(), this.refreshOptions(!1), !0 } advanceSelection(t, e) { var i, s; this.rtl && (t *= -1), this.inputValue().length || (it(Q, e) || it("shiftKey", e) ? (s = (i = this.getLastActive(t)) ? i.classList.contains("active") ? this.getAdjacent(i, t, "item") : i : t > 0 ? this.control_input.nextElementSibling : this.control_input.previousElementSibling) && (s.classList.contains("active") && this.removeActiveItem(i), this.setActiveItemClass(s)) : this.moveCaret(t)) } moveCaret(t) { } getLastActive(t) { let e = this.control.querySelector(".last-active"); if (e) return e; var i = this.control.querySelectorAll(".active"); return i ? k(i, t) : void 0 } setCaret(t) { this.caretPos = this.items.length } controlChildren() { return Array.from(this.control.querySelectorAll("[data-ts-item]")) } lock() { this.close(), this.isLocked = !0, this.refreshState() } unlock() { this.isLocked = !1, this.refreshState() } disable() { this.input.disabled = !0, this.control_input.disabled = !0, this.focus_node.tabIndex = -1, this.isDisabled = !0, this.lock() } enable() { this.input.disabled = !1, this.control_input.disabled = !1, this.focus_node.tabIndex = this.tabIndex, this.isDisabled = !1, this.unlock() } destroy() { var t = this.revertSettings; this.trigger("destroy"), this.off(), this.wrapper.remove(), this.dropdown.remove(), this.input.innerHTML = t.innerHTML, this.input.tabIndex = t.tabIndex, A(this.input, "tomselected", "ts-hidden-accessible"), this._destroy(), delete this.input.tomselect } render(t, e) { return "function" != typeof this.settings.render[t] ? null : this._render(t, e) } _render(t, e) { var i, s, n = ""; const o = this; return "option" !== t && "item" != t || (n = U(e[o.settings.valueField])), null == (s = o.settings.render[t].call(this, e, X)) ? s : (s = w(s), "option" === t || "option_create" === t ? e[o.settings.disabledField] ? E(s, { "aria-disabled": "true" }) : E(s, { "data-selectable": "" }) : "optgroup" === t && (i = e.group[o.settings.optgroupValueField], E(s, { "data-group": i }), e.group[o.settings.disabledField] && E(s, { "data-disabled": "" })), "option" !== t && "item" !== t || (E(s, { "data-value": n }), "item" === t ? (S(s, o.settings.itemClass), E(s, { "data-ts-item": "" })) : (S(s, o.settings.optionClass), E(s, { role: "option", id: e.$id }), o.options[n].$div = s)), s) } clearCache() { f(this.options, (t, e) => { t.$div && (t.$div.remove(), delete t.$div) }) } uncacheValue(t) { const e = this.getOption(t); e && e.remove() } canCreate(t) { return this.settings.create && t.length > 0 && this.settings.createFilter.call(this, t) } hook(t, e, i) { var s = this, n = s[e]; s[e] = function () { var e, o; return "after" === t && (e = n.apply(s, arguments)), o = i.apply(s, arguments), "instead" === t ? o : ("before" === t && (e = n.apply(s, arguments)), e) } } } }); var tomSelect = function (t, e) { return new TomSelect(t, e) };